#include <inttypes.h>
#include <sys/stat.h>
#include "utils.h"
#include "objc.h"

void objc_dump_headers(const char *header_output, uint64_t dylib_id_offset, uint64_t mach_end, char *filename, FILE *file, section_t *sections, bool is_64_bit, int arch_offsets, segment_t *segments, struct symbol_data_t *symbol_data)
{
    char *image_name;

	if (dylib_id_offset)
	{
		if (dylib_id_offset > mach_end)
		{
			image_name = malloc(strlen(filename) + 1);
			strcpy(image_name, filename);
		}
		else
		{
			struct dylib_command *dylib = read_bytes(file, dylib_id_offset, sizeof(struct dylib_command));
			image_name = read_string_v(file, dylib_id_offset + dylib->dylib.name.offset, "");
			free(dylib);
		}
	}
	else
	{
		image_name = malloc(strlen(filename) + 1);
		strcpy(image_name, filename);
	}

	struct stat st = {0};

	if (stat(header_output, &st) == -1)
		mkdir(header_output, 0700);

	uint32_t ncats = 0;
	uint32_t nprots = 0;
	uint32_t nclass = 0;

	section_t *catlist = section_by_name(sections, "__objc_catlist");

	if (catlist)
	{
		uint8_t width = is_64_bit ? 8 : 4;
		uint64_t category_offset = arch_offsets + catlist->offset;

		int count = catlist->size / width;
		int successful = count;

		for (int i = 0; i < count; i++)
		{
			uint64_t category_name;
			uint64_t category_inst_methods;
			uint64_t category_class_methods;

			if (is_64_bit)
			{
				uint64_t read_off = correct_offset(read_uint64_t(file, category_offset), segments);

				if (!read_off || read_off > mach_end)
				{
					err("Invalid category offset. Skipping.\n");
					successful--;
					continue;
				}

				struct objc2_category_64 *category = read_bytes(file, arch_offsets + read_off, sizeof(struct objc2_category_64));

				category_name = category->name;
				category_class_methods = category->class_methods;
				category_inst_methods = category->inst_methods;
				
				free(category);
			}
			else
			{
				uint64_t read_off = correct_offset(read_uint32_t(file, category_offset), segments);

				if (!read_off || read_off > mach_end)
				{
					err("Invalid category offset. Skipping.\n");
					successful--;
					continue;
				}

				struct objc2_category_32 *category = read_bytes(file, arch_offsets + read_off, sizeof(struct objc2_category_32));

				category_name = category->name;
				category_class_methods = correct_offset(category->class_methods, segments);
				category_inst_methods = correct_offset(category->inst_methods, segments);

				free(category);
			}

			category_offset += 8;

			char *extension = read_string_v(file, arch_offsets + category_name, "");
			char *symbol = 0;
			
			if (category_class_methods)
			{
				symbol = symbol_for_address(symbol_data, category_class_methods);
			}
			else if (category_inst_methods)
			{
				symbol = symbol_for_address(symbol_data, category_inst_methods);
			}

			if (!symbol || !category_name)
			{
				err("Failed to read objc category.\n");
				successful--;
				continue;
			}

			char *class_name = 0;

			if (strncmp("__OBJC_$_CATEGORY_CLASS_METHODS_NSData_", symbol, 32) == 0)
			{
				int index = 32;
				class_name = read_string_vm(symbol, &index, "$");
			}
			else if (strncmp("__OBJC_$_CATEGORY_INSTANCE_METHODS_", symbol, 35) == 0)
			{
				int index = 35;
				class_name = read_string_vm(symbol, &index, "$");
			}

			if (class_name)
			{
				class_name[strlen(class_name) - 1] = '\0';

				char *file_name = path_combine(header_output, class_name);

				file_name = realloc(file_name, strlen(file_name) + strlen(extension) + 4);
				strncat(file_name, "+", 1);
				strncat(file_name, extension, strlen(extension));
				strncat(file_name, ".h", 2);

				FILE *output = fopen(file_name, "w+");
				
				if (output)
				{
					printf("Found extension: %s+%s\n", class_name, extension);

					fprintf(output, "//\n// This header was generated by qd v1.0.0\n// Image name: %s\n//\n\n", image_name);
					fprintf(output, "@interface %s (%s)\n\n", class_name, extension);

					if (category_class_methods)
					{
						print_meth_list(file, output, arch_offsets, category_class_methods, 1, is_64_bit);
						fprintf(output, "\n");
					}

					if (category_inst_methods)
					{
						print_meth_list(file, output, arch_offsets, category_inst_methods, 0, is_64_bit);
						fprintf(output, "\n");
					}

					fprintf(output, "@end\n");
					fclose(output);
				}
				else
				{
					err("Failed to create file %s.\n", file_name);
					successful--;
				}
				
				free(file_name);
				free(class_name);
			}
			else
			{
				err("Failed to find extension class.\n");
				successful--;
			}

			free(extension);
		}

		ncats = successful;
	}

	section_t *protolist = section_by_name(sections, "__objc_protolist");

	if (protolist)
	{
		uint8_t width = is_64_bit ? 8 : 4;
		uint64_t prot_offset = arch_offsets + protolist->offset;

		int count = protolist->size / width;
		int successful = count;

		for (int i = 0; i < count; i++)
		{
			uint64_t protocol_name;
			uint64_t protocol_protocols;
			uint64_t protocol_class_meths;
			uint64_t protocol_inst_meths;
			uint64_t protocol_opt_class_meths;
			uint64_t protocol_opt_inst_meths;

			if (is_64_bit)
			{
				uint64_t read_off = correct_offset(read_uint64_t(file, prot_offset), segments);

				if (!read_off || read_off > mach_end)
				{
					if (!read_off || read_off > mach_end)
					{
						err("Invalid extension offset. Skipping.\n");
						successful--;
						continue;
					}
				}

				struct objc2_prot_64 *protocol = read_bytes(file, arch_offsets + read_off, sizeof(struct objc2_prot_64));

				protocol_name = protocol->name;
				protocol_protocols = protocol->protocols;
				protocol_class_meths = protocol->class_meths;
				protocol_inst_meths = protocol->inst_meths;
				protocol_opt_class_meths = protocol->opt_class_meths;
				protocol_opt_inst_meths = protocol->opt_inst_meths;
				
				free(protocol);
			}
			else
			{
				uint64_t read_off = correct_offset(read_uint32_t(file, prot_offset), segments);

				if (!read_off || read_off > mach_end)
				{
					err("Invalid extension offset. Skipping.\n");
					successful--;
					continue;
				}

				struct objc2_prot_32 *protocol = read_bytes(file, arch_offsets + read_off, sizeof(struct objc2_prot_32));

				protocol_name = correct_offset(protocol->name, segments);
				protocol_protocols = protocol->protocols;
				protocol_class_meths = protocol->class_meths;
				protocol_inst_meths = protocol->inst_meths;
				protocol_opt_class_meths = protocol->opt_class_meths;
				protocol_opt_inst_meths = protocol->opt_inst_meths;
				
				free(protocol);
			}
			
			prot_offset += width;

			if (protocol_name > mach_end)
			{
				err("Protocol name outside of binary.\n");
				successful--;
				continue;
			}

			char *name = read_string_v(file, arch_offsets + protocol_name, "");

			char *file_name = path_combine(header_output, name);
			file_name = realloc(file_name, strlen(file_name) + 3);
			strncat(file_name, ".h", 3);

			FILE *output = fopen(file_name, "w+");

			if (output)
			{
				printf("Found protocol: %s\n", name);

				fprintf(output, "\n//\n// This header was generated by qd v1.0.0\n// Image name: %s\n//\n\n", image_name);
				fprintf(output, "@protocol %s", name);

				if (protocol_protocols)
				{
					print_protocols(file, output, arch_offsets, protocol_protocols, is_64_bit);
				}

				fprintf(output, "\n\n");

				if (protocol_class_meths)
				{
					print_meth_list(file, output, arch_offsets, protocol_class_meths, 1, is_64_bit);
					fprintf(output, "\n");
				}

				if (protocol_inst_meths)
				{
					print_meth_list(file, output, arch_offsets, protocol_inst_meths, 0, is_64_bit);
					fprintf(output, "\n");
				}

				if (protocol_opt_class_meths || protocol_opt_inst_meths)
					fprintf(output, "@optional\n");

				if (protocol_opt_class_meths)
				{
					print_meth_list(file, output, arch_offsets, protocol_opt_class_meths, 1, is_64_bit);
					fprintf(output, "\n");
				}

				if (protocol_opt_inst_meths)
				{
					print_meth_list(file, output, arch_offsets, protocol_opt_inst_meths, 0, is_64_bit);
					fprintf(output, "\n");
				}
			
				fprintf(output, "@end\n");
				fclose(output);
			}
			else
			{
				err("Failed to create file %s.\n", file_name);
				successful--;
			}

			free(name);
		}
		
		nprots = successful;
	}

	section_t *classlist = section_by_name(sections, "__objc_classlist");
	
	if (classlist)
	{
		uint8_t width = is_64_bit ? 8 : 4;
		uint64_t class_offset = arch_offsets + classlist->offset;

		int count = classlist->size / width;
		int successful = count;

		for (int i = 0; i < count; i++)
		{
			uint64_t ro_name;
			uint64_t ro_base_prots;
			uint64_t ro_ivars;
			uint64_t ro_base_props;
			uint64_t ro_base_meths;
			uint64_t metaro_base_meths;
			uint64_t superclass;

			if (is_64_bit)
			{
				uint64_t read_off = correct_offset(read_uint64_t(file, class_offset), segments);

				if (!read_off || read_off > mach_end)
				{
					err("Invalid class offset. Skipping %lx\n", read_off);
					successful--;
					continue;
				}

				struct objc2_class_64 *class = read_bytes(file, arch_offsets + read_off, sizeof(struct objc2_class_64));
				struct objc2_class_64 *metaclass = read_bytes(file, arch_offsets + class->isa, sizeof(struct objc2_class_64));
				struct objc2_class_ro_64 *ro = read_bytes(file, arch_offsets + class->info, sizeof(struct objc2_class_ro_64));
				struct objc2_class_ro_64 *metaro = read_bytes(file, arch_offsets + metaclass->info, sizeof(struct objc2_class_ro_64));

				ro_name = correct_offset(ro->name, segments);
				ro_base_prots = ro->base_prots;
				ro_ivars = ro->ivars;
				ro_base_props = ro->base_props;
				ro_base_meths = ro->base_meths;
				metaro_base_meths = metaro->base_meths;
				superclass = class->superclass;

				free(class);
				free(metaclass);
				free(ro);
				free(metaro);
			}
			else
			{
				uint64_t read_off = correct_offset(read_uint32_t(file, class_offset), segments);

				if (!read_off || read_off > mach_end)
				{
					err("Invalid class offset. Skipping.\n");
					successful--;
					continue;
				}

				struct objc2_class_32 *class = read_bytes(file, arch_offsets + read_off, sizeof(struct objc2_class_32));
				struct objc2_class_32 *metaclass = read_bytes(file, arch_offsets + class->isa, sizeof(struct objc2_class_32));
				struct objc2_class_ro_32 *ro = read_bytes(file, arch_offsets + class->info, sizeof(struct objc2_class_ro_32));
				struct objc2_class_ro_32 *metaro = read_bytes(file, arch_offsets + metaclass->info, sizeof(struct objc2_class_ro_32));

				ro_name = correct_offset(ro->name, segments);
				ro_base_prots = ro->base_prots;
				ro_ivars = ro->ivars;
				ro_base_props = ro->base_props;
				ro_base_meths = ro->base_meths;
				metaro_base_meths = metaro->base_meths;
				superclass = class->superclass;

				free(class);
				free(metaclass);
				free(ro);
				free(metaro);
			}
			
			class_offset += width;

			if (ro_name > mach_end)
			{
				successful--;
				err("Class name outside of binary. %lx\n", ro_name);
				continue;
			}

			char *name = name = read_string_v(file, arch_offsets + ro_name, "");

			char *file_name = path_combine(header_output, name);
			file_name = realloc(file_name, strlen(file_name) + 3);
			strncat(file_name, ".h", 3);

			FILE *output = fopen(file_name, "w+");

			if (output)
			{
				printf("Found class: %s\n", name);

				char *super = 0;

				if (superclass)
				{
					char *symbol = symbol_for_address(symbol_data, superclass);

					if (strncmp(symbol, "_OBJC_CLASS_$_", 14) == 0)
						super = symbol + 14;
				}
				else
				{
					// symbol is external
				}

				fprintf(output, "\n//\n// This header was generated by qd v1.0.0\n// Image name: %s\n//\n", image_name);

				if (super || ro_base_prots)
				{
					// fprintf(output, "\n");
				}

				if (super)
				{
					// fprintf(output, "#import \"%s.h\"\n", super);
				}

				char *protocol_list = 0;

				if (ro_base_prots)
				{
					protocol_list = print_protocols(file, output, arch_offsets, ro_base_prots, is_64_bit);
				}

				if (ro_base_props)
				{
					fprintf(output, "\n");
					print_forward_declarations(file, output, arch_offsets, ro_base_props, is_64_bit);
				}

				fprintf(output, "\n@interface %s : %s", name, super ?: "NSObject");

				if (protocol_list)
				{
					fprintf(output, " %s", protocol_list);
					free(protocol_list);
				}

				fprintf(output, "\n\n");

				if (ro_ivars)
				{
					print_ivars(file, output, arch_offsets, ro_ivars, is_64_bit);
					fprintf(output, "\n");
				}

				if (ro_base_props)
				{
					print_properties(file, output, arch_offsets, ro_base_props, is_64_bit);
					fprintf(output, "\n");
				}

				if (metaro_base_meths)
				{
					print_meth_list(file, output, arch_offsets, metaro_base_meths, 1, is_64_bit);
					fprintf(output, "\n");
				}

				if (ro_base_meths)
				{
					print_meth_list(file, output, arch_offsets, ro_base_meths, 0, is_64_bit);
					fprintf(output, "\n");
				}

				fprintf(output, "@end\n");
				fclose(output);
			}
			else
			{
				err("Failed to create file %s.\n", file_name);
				successful--;
			}

			free(name);
			free(file_name);
		}
	
		nclass = successful;
	}

	if (ncats || nprots || nclass)
	{
		printf("\n");

		if (ncats)
			printf("Dumped %" PRId32 " extension%s.\n", ncats, ncats == 1 ? "" : "s");

		if (nprots)
			printf("Dumped %" PRId32 " protocol%s.\n", nprots, nprots == 1 ? "" : "s");

		if (nclass)
			printf("Dumped %" PRId32 " class%s.\n", nclass, nclass == 1 ? "" : "es");
	}

	free(image_name);
}